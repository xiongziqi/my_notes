# 维特比算法
[link](http://www.cim.mcgill.ca/~latorres/Viterbi/va_alg.htm)

本章将详细介绍维特比算法。维特比算法是一个在有限状态(finite-state)，离散时间(discrete-time)的马尔科夫过程里以最大后验概率(posteriori)寻找一个最可能个状态的高效算法。该算法一般归入一般统计框架**复合决策理论(compound decision theory)**中。

## 复合决策理论
假设我们有一个含有n个字符的文本。每个字符有一个特征向量$z_i$，$i=1,2,...,n$。$p(Z|C)$表示在给定序列$C=c_1,c_2,...,C_n$下，向量序列$Z=z_1,z_2,...,z_n$的条件概率密度函数，其中，$z_k$表示第$k$个字符的特征向量，$c_k$可以取$M$个值（字母表中的字母），$k=1,2,...,n$。同时，用$P(c)$表示序列$C$的先验概率。话句话说，$P(C)$是$n$个字符组成的所有序列的先验概率分布。因此，通过选择最大化后验概率的字符序列就能最大化正确分类文本的概率。即：给定$P(C|Z)$，最大化后验概率(**MAP**)。
由贝叶斯理论，有：
$$P(C|Z) = \frac{P(Z|C)P(C)}{p(Z)}\tag{1}$$
而$p(Z)$与序列$C$独立($C$只是一个缩放因子)，我们只需要最大化判别式函数
$$g_c(Z) = p(Z|C)P(C)\tag{2}$$
由于计算$(2)$式需要存储巨量的概率信息，所以，实际使用时，我们会做一些合理假设以简化问题：
> * 序列的观察状态数量不能太大。用$n$表示一个单词的长度，$P(C)$表示单词出现的频率。
> * 特征向量之间条件独立。给定位置字符对应的特征向量与相邻字符的特征向量概率独立，即只依赖于该位置的字符。

给定上述假设后，$(2)$式可以约减为
$$g_c(Z) = \sum_{i=1}^n \log{p(z_i|c_i)} + \log{P(c_1,...,c_n)}\tag{3}$$
r如果我们假设上述过程是一阶马尔可夫过程，则$(3)$可以约减为
$$g_c(Z) = \sum_{i=1}^n\log{p(z_i|c_i)}+\log{[P(c_1|c_0)+P(c_2|c_1)+...+P(c_n|c_{n+1})]}\tag{4}$$
**MAP**序列估计问题可以看成在指定图上的最短路径问题。通过这种相似性，我们可以看到维特比算法天然的递归属性。
为了阐述维特比算法求解最短路径的思路，我们需要用一个简单的方式来表述一个马儿可夫过程。通常我们会使用如下图2所示的**状态图**。在这个状态图中，节点表示状态，箭头表示转移，随着时间推移，该过程会追溯从一个状态转移到另一个状态的路径。

![图2 具有三个状态过程的状态图](https://raw.githubusercontent.com/zqxiong/my_legend/master/viterbi_algorithm_fig2.gif)

一个更加详细描述如图3.一般称为**格子图(trellis)**。在格子图中，每个节点(node)对应给定时刻的一个状态，每个箭头表示到下一个即时时刻的新状态的转移。格子图的开始和终止状态称为$c_0$和$c_n$。其最重要的属性是每个可能的状态序列$C$都对应格子图中唯一的一条路径，反之亦然。

![图3 三个状态对应的格子图](https://raw.githubusercontent.com/zqxiong/my_legend/master/viterbi_algorithm_fig3.gif)

现在，假设我们给每一条路径一个长度，其值与$-\log{[p(Z|C)+P(C)]}$成正比。由于$\log{()}$是一个单调的函数，因此我们可以在路径和序列之间简历一一对应的关系，所以，我们仅需找到一条路径，其$-\log{[p(Z|C)+P(C)]}$最小，而状态序列的$p(Z|C)P(C)$最大，换句话说，状态序列会有一个最大后验概率（MAP），而这个正式我们要解决的问题。状态序列$C$对应的路径的**总长度**为：
$$-\log{[p(Z|C)P(C)]} = \sum_{k=1}^n {l(t_k)}$$
其中，$l(t_k)$是从$c_k$到$c_{k+1}$的每一个转移$t_k$的长度。最短的那条路径片段被称为节点$c_k$的**幸存者**，记为$S(c_k)$。对于任意时刻$k>0$，总共会有$M$个幸存者，每个对应一个$c_k$。观察如下：最短的完整路径$S$必须始于这些幸存者中的一个。所以对于任意时刻$k$，我们仅需要记住$M$个幸存者$S(c_k)$以及他们对应的路径。为了获得$k+1$时刻的路径，我们仅需在**$k$时刻**的幸存者的基础上扩展一个时间单元上扩展路径片段的长度。这个算法是**forward dynamic programming**的简单版本。

w我们通过一个5个时间单元，4个状态的格子图来描述整个过程。图4展示了整个格子图的信息，每条分支都赋予了一个长度。

![图4 标定分支长度的格子图；M=4, n=5](https://raw.githubusercontent.com/zqxiong/my_legend/master/viterbi_algorithm_fig4.gif)

t图5展示了从算法开始状态到结束状态递归决策最短路径的步骤。每一步都只展示了4（或者更少）个幸存者以及相应的长度。

![viterbi算法的最短路径递归决策过程](https://raw.githubusercontent.com/zqxiong/my_legend/master/viterbi_algorithm_fig5.gif)

**Viterbi**算法描述如下：


> **Input:**

>> $Z=z_1,z_2,...,z_n$  the input observed sequency

> **Initialization:**

>> $k=1$                      time index
>> $S(c_1)=c_1$           
>> $L(c_1)=0$               this is a variable that accumulate the langths, the initial lanth is 0

> **Recursion:**

>> For all transitions $t_k=(c_k,c_{k+1})$

>> > compute: $L(c_k,c_{k+1}=L(c_k)+l{[t_k=(c_k,c_{k+1})]}$

>> Find $L(c_k+1) = \min{L(c_k, c_{k_1})}$

>> For each $c_{k+1}$

>> > store $L(c_{k+1})$ and the corresponding survivor $S(c_{k+1})$

>> $k=k+1$

>> Repeat until $k=n$

d对于有限状态序列$C$，算法在时刻$n$终止，并得到$S(c_k)$作为最短路径。
u
s算法的复杂度很容易估计：

> **内存：**算法需要$M$个存储空间，每个空间对应一个状态，每个空间必须要能够存储一个长度为$L(m)$的数值以及一个存储符号的列表$S(m)$。
> **计算：**在每个时间片算法需要至多$M^2$次加法，每次加法对应一个现有的状态转移以及$M^2$次计算上的$M$次比较。
